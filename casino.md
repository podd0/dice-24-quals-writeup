# rps-casino
## The ctf
We have a custom LFSR rng, and we have 56 free observations to make before being able to fully predict it. 
This is the generator:
```python
def LFSR():
	state = bytes_to_long(os.urandom(8))
	print("secret : ", state)
	while 1:
		yield state & 0xf
		for i in range(4):
			bit = (state ^ (state >> 1) ^ (state >> 3) ^ (state >> 4)) & 1
			state = (state >> 1) | (bit << 63)

rng = LFSR()
```
For 56 times, the server will give us the value of `next(rng) % 3`, then we have to guess for 50 times the next values of `next(rng) % 3`

## Observations
Now we can see that each time we generate a random 4-bits number, which is just `state&0xf`, four new MSBs are created. 
We can see that the new bits only depend on the 8 LSBs of the state at the time `next(rng)` is called. 
Now let's number the ith rng value we're getting, let's call it $x_i$. 
This basically means that our initial state will be $x_{15}, x_{14} ..., x_0$, concatenated in a single integer (each $x_i$ is a 4 bit number, 4*16 = 64).
Also $x_{16}$ only depends on the 8 LSBs of state, which are $x_0$ and $x_1$. This means that by repeating this step, $x_i$ depends on $x_{i-15}$ and $x_{i-16}$. 
We can build this "dependency graph":

![image](https://raw.githubusercontent.com/podd0/dice-24-quals-writeup/main/graph.png)

This is just a part of it, but from this we can notice which queries depend on just $x_0, x_1, x_2, x_3$.  
An $x_i$ is generated by all the nodes pointing at it. This also shows that there's a nice number of constraints on each 16 adjacent bits, we can try to bruteforce all 
the possible values of $x_0, x_1, x_2, x_3$ that are coherent with the data we have on the rng. This means we just make a list of all the values that give the same moduli
in the rng queries shown in the image as the ones we get from the server. Turns out this list will be very small, usually ranging from 1 to at most 10 entries.
## Combine
Now we can divide the state in four 16bits numbers, retrieve the possible values for each of these parts of the state and then find out which combination satisfies all of the constraints 
(notice that the union of the four subgraphs doesn't cover the whole dipendency graph as we don't have $x_{19}$, which needs both $x_3$ and $x_4$ to be generated. This is why we need to make an additional check of the whole state).

## Code

```python
import os
from pwn import *
from itertools import product
from functools import reduce

def advance(state):
	for i in range(4):
		bit = ((state ^ (state >> 1) ^ (state >> 3) ^ (state >> 4)) & 1)
		state = ((state >> 1) | (bit << 63))
	return state


mods = []
# r = process("source.py")
r = remote("mc.ax", 31234)

for i in range(56):
	r.recvuntil(b"Choose rock, paper, or scissors: ")
	r.sendline(b"paper")
	res = r.recvline()
	rem = 0
	if res.startswith(b"Tie"):
		rem = 1
	elif res.startswith(b"You lose"):
		rem = 2
	mods += [rem]

good = [[] for i in range(4)]
to_check = {0, 1, 2, 3, 16, 17, 18, 32, 33, 48}

for j in range(4):
	print("checks :", to_check)
	for bm in range(1<<16):
		thisgood = True
		bm <<= (16*j)
		cbm = bm
		for i in range(56):
			if i in to_check and (bm&0xf)%3 != mods[i]:
				thisgood = False
				break
			bm = advance(bm)
		if thisgood:
			good[j] += [cbm]
	to_check = {x+4 for x in to_check}

it = reduce(product, [range(len(x)) for x in good])
sol = 0
for (((i0, i1), i2), i3) in it:
	ind = (i0, i1, i2, i3)
	bm = 0
	for j in range(4):
		bm |= good[j][ind[j]]
	thisgood = True
	cbm = bm
	for i in range(56):
		if (bm&0xf)%3 != mods[i]:
			thisgood = False
			break
		bm = advance(bm)
	if thisgood:
		sol = cbm
		break

for i in range(56):
	sol = advance(sol)

rps = ["rock", "paper", "scissors", "rock"]

for i in range(50):
	choice = (sol & 0xf)%3
	r.sendline(rps[choice+1].encode())
	sol = advance(sol)
r.interactive()
```

