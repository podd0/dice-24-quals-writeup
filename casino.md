# rps-casino
## The ctf
We have a custom LFSR rng, and we have 56 free observations to make before being able to fully predict it. 
This is the generator:
```python
def LFSR():
	state = bytes_to_long(os.urandom(8))
	print("secret : ", state)
	while 1:
		yield state & 0xf
		for i in range(4):
			bit = (state ^ (state >> 1) ^ (state >> 3) ^ (state >> 4)) & 1
			state = (state >> 1) | (bit << 63)

rng = LFSR()
```
For 56 times, the server will give us the value of `next(rng) % 3`, then we have to guess for 50 times the next values of `next(rng) % 3`

## Observations
Now we can see that each time we generate a random 4-bits number, which is just `state&0xf`, four new MSBs are created. 
We can see that the new bits only depend on the 8 LSBs of the state at the time `next(rng)` is called. 
Now let's number the ith rng value we're getting, let's call it $x_i$. 
This basically means that our initial state will be $x_{15}, x_{14} ..., x_0$, concatenated in a single integer (each $x_i$ is a 4 bit number, 4*16 = 64).
Also $x_{16}$ only depends on the 8 LSBs of state, which are $x_0$ and $x_1$. This means that by repeating this step, $x_i$ depends on $x_{i-15}$ and $x_{i-16}$. 
We can build this "dependency graph":

(![https](https://github.com/podd0/dice-24-quals-writeup/graph.png))

An $x_i$ is generated by all the nodes pointing at it. This also shows that there's a nice number of constraints on each 16 adjacent bits, we can try to bruteforce all 
the possible values of $x_0, x_1, x_2, x_3$ that are coherent with the data we have on the rng. This means we just make a list of all the values that give the same moduli
in the rng queries shown in the image as the ones we get from the server

